\section{Sensoren/Aktoren und Kommunikation}\label{ch:sensoren_kommunikation}

\newline Die verwendete Hardware-Plattform ist bei allen Sensorknoten ein Raspberry-Pi. Da der vorliegende Anwendungsfall keine große Leistungsfähigkeit der Hardware benötigt, wird für die Sensorknoten ein Model 3B verwendet. Um skalierbar zu bleiben und auch einen Puffer an Leistung für eventuelle zukünftige Funktionalitäten zu haben, wird für den Server ein Raspberry-Pi Model 4 verwendet.
\newline Für das Auslesen der Sensoren und das Ansteuern der Aktoren werden zum einen direkt die GPIO-Pins des Raspberry-Pis verwendet und zum anderen dessen vorhandene I2C-Schnittstelle. Analoge Sensoren können vom Raspberry-Pi nicht direkt ausgelesen werden, da dieser über keine integrierten Analog-Digital-Converter (ADC) verfügt. Hierfür werden die im auf der Platine aufgebrachten Microcontroller vorhandenen ADCs verwendet. Deren Werte können ebenfalls über I2C abgefragt werden.
\newline Die gemessenen Werte werden je nach Art des Sensors entweder zyklisch abgefragt und mittels OPC-UA an den Server übergeben oder bei Werteänderung azyklisch per OPC-UA übertragen.

\subsection{OPC-UA Server}
Die Server-Anwendung importiert das Informationsmodell, legt mit diesem den Server an und startet ihn. Realisiert wurde diese mit der Python Library "python-opcua" von FreeOpcUa. Das verwendete Informationsmodell wurde mit dem Modellierungstool Siome erstellt und orientiert sich an dem Beispiel aus Abbildung 1. Da weder Siome noch die verwendete Library direkt Validierungsfunktionalitäten für das erstellte Informationsmodell unterstützen, wurde aus Zeitgründen hierauf verzichtet.

\subsection{OPC-UA Clients}
\newline Die Client Anwendung wurde ebenfalls in Python mit der gleichen Bibliothek verwirklicht. Außerdem wird hier neben dem Ansteuern/Auslesen der Sensoren/Aktoren auch die Kommunikation mit dem OPC-UA Server und eine Steuerungsfunktionalität direkt am Knoten mit den vorhandenen Buttons realisiert. 
\newline Im Hauptskript \textbf{Client.py} werden zunächst alle Sensor- und Aktorobjekte angelegt, sowie benötigte Threads gestartet und Callbacks hinterlegt. 
\newline Im \textbf{„measurement\textunderscore thread“} werden Temperatur, Luftfeuchtigkeit, Luftdruck und Luftqualität einmal pro Minute abgefragt und die entsprechenden Werte auf dem Display aktualisiert, sowie an den OPC-UA Server übermittelt. Entsprechend des Wertes für Luftqualität werden die vorhandenen LEDs geschalten, bzw. zusätzlich über den vorhandenen Buzzer ein Alarmton ausgegeben.

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|ll}
\cline{1-3}
\textbf{CO2-Gehalt}                        & \textbf{LED aktiv} & \textbf{Alarm} &  &  \\ \cline{1-3}
\textless 800 ppm                          & Grün               & -              &  &  \\ \cline{1-3}
\textgreater 800 ppm \& \textless 1200 ppm & Gelb               & -              &  &  \\ \cline{1-3}
\textgreater 1200 ppm                      & Rot                & +              &  &  \\ \cline{1-3}
\end{tabular}
\end{table}

\newline Der \textbf{Bewegungssensor} stellt einen Event-Handler zur Verfügung, der abonniert werden kann. Bei Auftreten einer Bewegung wird das Event ausgelöst und ruft die hinterlegte Callback-Funktion auf, welche dem OPC-UA Server Anwesenheit signalisiert. Sobald eine Minute lang keine Bewegung mehr gemessen wird, wird das Event erneut ausgelöst und die Callback-Funktion setzt den entsprechenden Wert im Informationsmodell auf Abwesenheit.
\newline Um auf dem \textbf{LCD-Display} unterschiedliche Texte (Screens) anzeigen zu können und außerdem eine Referenzmessung des Luftqualitätssensors auszulösen, wurde ebenfalls eine \textbf{Steuerungsfunktionalität} mittels der Buttons implementiert. Das LCD-Display führt intern eine Liste mit anzuzeigenden Texten, die durch Knopfdruck durchgeschalten werden können. Ebenfalls durch Knopfdruck kann die erwähnte Referenzmessung des Luftqualitätssensors eingestellt und gestartet werden.
\newline Für das Ansteuern des \textbf{LCD-Displays} aus OPC-UA heraus wurde hierfür ein eigener Screen hinterlegt. Bei Änderung des entsprechenden Wertes im Informationsmodell wird mittels \textbf{Publish/Subscribe} der anzuzeigende Text aktualisiert.
